<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: Routes/Thread-page/thread-page.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: Routes/Thread-page/thread-page.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>import React, { Component } from 'react';
import Thread from '../Thread/Thread';
import GoHome from '../GoHome/index.js';
import AddComment from '../AddComment/AddComment';
import './thread-page.css';
import { Link, Route, Switch } from 'react-router-dom';
import axios from '../../axios-orders';

class ThreadPage extends Component {
   state = {
      id: window.location.href.split("/").pop(),
      comments: [],
      subredditName: window.location.href.split("srName=").pop().replace("#top", ""),
      editThread: false,
      threadBody: '',
      threadTitle: '',
      creator: '',
      postdate: '',
      votes: 0,
      editComment: false,
      replyComment: false,
      editID: '',
      replyID: '',
      deleteID: '',
      error: false,
      errornumber: 0

   }

   async componentDidMount() {
      let srName = this.state.subredditName;
      let threadID = this.state.id;
      axios.get(`/sr/${srName}/thread/${threadID}`)
         .then(resp => {
            if (resp.data &amp;&amp; resp.status === 200) {
               this.setState({
                  subredditName: resp.data.subredditName,
                  threadBody: resp.data.body,
                  postdate: resp.data.postDate,
                  threadTitle: resp.data.title,
                  votes: resp.data.votes,
                  creator: resp.data.creatorUsername,
                  image: resp.data.postFile === "none" ? null : resp.data.postFile,
                  isSpoiler: resp.data.spoiler
               });
            }
         });

      // var headers = {
      //    auth: localStorage.getItem("token")
      // }

      // axios.get('/comment/all/' + this.state.id, { headers: headers })
      //    .then(res => {
      //       if (res.status == 200) {
      //          console.log(res)

      //          //Removing duplicate comments:
      //          // for(let i = 0; i &lt; res.data.comments.length; i++){
      //          //    for(let x = i+1; x &lt; res.data.comments.length; x++){
      //          //       if(res.data.comments[i]._id === res.data.comments[x]._id){
      //          //          res.data.comments.splice(x, 1);
      //          //       }
      //          //    }
      //          // }
      //          // for (let comment of res.data.comments) {
      //          // }



      //          for (let comment of res.data.comments) {
      //             comment.children = [];
      //             axios.get(`/comment/all/${comment._id}?comment=true`)
      //                .then(resp => {
      //                   if (resp.data &amp;&amp; resp.status === 200) {
      //                      let comments = this.state.comments;
      //                      for (const commentState of comments) {
      //                         if (commentState._id === comment._id) {
      //                            commentState.children = resp.data.comments;
      //                         }
      //                      }
      //                      this.setState({
      //                         comments: comments
      //                      })
      //                   }
      //                });

      //          }

      //          this.setState({
      //             comments: res.data.comments
      //          });
      //       }
      //       else if (res.status === 404) {
      //          alert("Not Found");
      //          return Response.json;
      //       }
      //    })
      //    .catch(error => {
      //       console.log(error);
      //    })

      let comments = await this.getComments(threadID)
      comments = comments.filter(comment => comment.length);
      console.log(comments);
      let commentsGrouped = comments;
      // for (const comment of comments) {
      //    // const isThereSimilar = commentsGrouped.findIndex(cGroup => {
      //    //    return cGroup.findIndex(c => c.parent_id === comment.parent_id) > 0
      //    // });
      //    // if (isThereSimilar > -1) {
      //    //    console.log("found one")
      //    //    commentsGrouped[isThereSimilar].push(comment);
      //    // } else {
      //    //    console.log("none found")
      //    //    commentsGrouped.push([comment]);
      //    // }
      //    comment.children = [];
      // }
      // for (let i = 0; i&lt;comments.length; i++) {
      //    //Search for its children...
      //    for(let j = i + 1; j &lt; comments.length; j++){
      //       if(comments[j].parent_id === comments[i]._id){
      //          comments[i].children.push(comments[j]);
      //       }
      //    }
      // }
      // console.log(comments);

      //Now we need to link them...
      //First group ==> comments
      //Other groups => replies;
      // if(!commentsGrouped.length) return;
      for (let i = comments.length - 1; i > 0; i--) {
         const parentID = comments[i][0].parent_id;
         //Search for it's parent...
         for (let j = 0; j &lt; i; j++) {
            for (let parent of comments[j]) {
               if (parent._id === parentID) {
                  parent.children = comments[i];
               }
            }
         }
      }
      this.setState({ allComments: comments[0] }, () => {
         console.log(this.state.allComments);
      })


   }

   getCommentsJSX(comments) {
      if (!comments) return;
      return comments.map(comment => {
         return &lt;ul className="threadComment" >
            &lt;div className="commentUser">u/{comment.username} &lt;/div>
            &lt;div className={`comment ${comment.spoiler ? "spoiler" : ""}`}>{comment.content}&lt;/div>
            {!comment.locked ?
               &lt;button className="replyComment" comment-id={comment._id} onClick={this.handleReply} >Reply&lt;/button>
               : null
            }
            {localStorage.getItem("Username") === comment.username ?
               &lt;span>
                  &lt;button className="editComment" data-id={comment._id} onClick={this.editComment.bind(this)}>Edit&lt;/button>
                  &lt;button className="deleteComment" data-id={comment._id} onClick={this.deleteComment.bind(this)}>Delete&lt;/button>
               &lt;/span>
               : null}
            {this.getCommentsJSX(comment.children)}&lt;/ul>
      })
   }

   /**
    * Handles edit thread boolean in the state.
    * @function editPost
    */
   editPost = (e) => {
      e.preventDefault();
      this.setState({
         editThread: true
      })
   };
    /**
    * Handles canceling thread boolean in the state.
    * @function cancelEdit
    */
   cancelEdit = (e) => {
      e.preventDefault();
      this.setState({
         editThread: false
      })
   };
    /**
    * Handles the edit request for the thread.
    * @function handleEdit
    */
   handleEdit = (e) => {
      this.setState({
         error: false,
         errornumber: 0
      })
      e.preventDefault();
      console.log('Edit Clicked');

      let checker = "";

      if (document.getElementById("newThreadTitleField").value === checker) {
         this.setState({
            error: true,
            errornumber: 1
         })
         //alert("Please provide a new title");
         return;
      }
      else if (document.getElementById("newThreadBodyField").value === checker) {
         this.setState({
            error: true,
            errornumber: 2
         })
         //alert("Please provide a new bodyfor the thread");
         return;
      }
      let headers = {
         auth: localStorage.getItem("token")
      }
      var threadData = {
         title: document.getElementById("newThreadTitleField").value,
         threadBody: document.getElementById("newThreadBodyField").value
      }
      let SubredditName = this.state.subredditName;
      let threadID = this.state.id;
      axios.put('/sr/' + SubredditName + '/thread/' + threadID, threadData, { "headers": headers })
         .then(res => {
            if (res.status == 200) {
               console.log(res)
               alert('Post Edited Successfully');
               this.setState({
                  editThread: false
               })
            }
         })
         .catch(error => {
            alert(error.Response);
         })
   }
 /**
    * Handles the delete request for the thread.
    * @function delPost
    */
   delPost = (e) => {
      //e.preventDefault();
      console.log('Delete Clicked');

      var headers = {
         auth: localStorage.getItem("token")
      }
      let SubredditName = this.state.subredditName;
      let threadID = this.state.id;
      axios.delete('/sr/' + SubredditName + '/thread/' + threadID, { "headers": headers })
         .then(res => {
            if (res.status == 200) {
               console.log(res);
               alert('Thread Deleted Successfully!');
               window.location.href = "/"

            }
         })
         .catch(error => {
            alert(error.response);
         })
   }





   replyComment(e) {
      e.preventDefault();
      const comment = document.getElementById("textReply").value.trim();
      this.addComment(comment, {
         id: this.state.replyTo
      });
   }
   addComment = (comment, data) => {
      var newComment = {
         username: localStorage.getItem("Username"),
         content: comment,
         reply: Boolean(data || false),
         spoiler: document.getElementById("checkSpoiler").checked,
         locked: document.getElementById("checkLocked").checked
      }



      var headers = {
         auth: localStorage.getItem("token")
      }
      // var newComment = {
      //    // username: localStorage.getItem("username"),
      //     content:comment,
      //     reply: false,
      //     spoiler: document.getElementById("checkSpoiler").checked,
      //     locked: document.getElementById("checkLocked").checked
      //  }
      const id = data &amp;&amp; data.id ? data.id : this.state.id
      // alert(id);
      axios.post('/comment/' + id, newComment, { headers: headers })
         .then(res => {
            if (res.status == 200) {
               console.log(res)
               window.location.reload();
            }
         })
         .catch(error => {
            alert(error.response);
         })

   }




   editComment = (e) => {
      e.preventDefault();
      this.setState({
         editComment: true

      })
      const id = e.target.getAttribute("data-id");
      this.setState({
         editID: id
      })
   }




   goEdit = (e) => {
      e.preventDefault();
      const Cid = this.state.editID;
      console.log(Cid);
      /*const newComment = {
         id: Cid,
         username: localStorage.getItem("username"),
         content: document.getElementById("textComment").value,
         //  reply: false,
         spoiler: document.getElementById("checkSpoiler2").checked,
         locked: document.getElementById("checkLocked2").checked


      }*/


      console.log('Edit Clicked');
      var commentData = {
         newCommentID: Cid,
         content: document.getElementById("textComment").value,
         locked: document.getElementById("checkLocked2").checked,
         spoiler: document.getElementById("checkSpoiler2").checked
      }
      let checker = "";

      if (document.getElementById("textComment").value === checker) {
         alert("Please provide a new Comment");
         return;
      }
      // else {
      //this.setState({comments:[...this.state.comments.forEach(comment=>comment.id==Cid),comment.comment=newComment.comment]});
      //  this.setState({ comments: [...this.state.comments, newComment] });

      //}
      var headers = {
         auth: localStorage.getItem("token")
      }


      axios.put('/comment/' + Cid, commentData, { headers: headers })
         .then(res => {
            if (res.status == 200) {
               console.log(res)
               const btn = document.querySelector(`button[data-id="${Cid}"]`)
               const container = btn.parentElement.parentElement
               const comment = container.querySelector(".comment");
               comment.textContent = commentData.content;
               if(commentData.locked){
                  container.querySelector(".replyComment").remove();
               }else{
                  if(container.querySelector(".replyComment")) return;
                  const replyBtn = document.createElement("button");
                  replyBtn.classList.add("replyComment");
                  replyBtn.innerHTML = `&lt;i class="fas fa-reply">&lt;/i>`;
                  replyBtn.setAttribute("comment-id", Cid);
                  comment.after(replyBtn);
               }
               if(commentData.spoiler){
                  container.classList.add("spoiler")
               }else{
                  container.classList.remove("spoiler")
               }
               this.setState({editComment: false})
            }
         })
         .catch(error => {
            alert(error.response);
         })
   }
   deleteComment = (e) => {
      const id = e.target.getAttribute("data-id");
      const container = e.target.parentElement.parentElement;
      this.setState({
         deleteID: id
      })
      //this.setState({ comments: [...this.state.comments.filter(comment => comment._id !== id)] });
      console.log(id);
      //e.preventDefault();
      console.log('Delete Clicked');
      var headers = {
         auth: localStorage.getItem("token")
      }
      axios.delete('/comment/' + id, { "headers": headers })
         .then(res => {
            if (res.status == 200) {
               console.log(res);
               container.remove();
               alert('Comment Deleted Successfully!');

            }
         })
         .catch(error => {
            alert(error.response);
         })
   }


   cancelEditComment = (e) => {
      e.preventDefault();
      this.setState({
         editComment: false
      })
   }

   handleReply = (e) => {
      e.preventDefault();
      this.setState({
         replyComment: true

      })
      let id = e.target.getAttribute("comment-id");
      while (!id) {
         e.target = e.target.parentElement;
         id = e.target.getAttribute("comment-id");
      }
      // alert(id);
      this.setState({
         replyTo: id

      })

   }

   cancelReplyComment = (e) => {
      e.preventDefault();
      this.setState({
         replyComment: false
      })
   }

   //A recursive function to get all All levels of replies for a comment...
   //level 1 === replies for the comment
   //level 2 === replies of a reply
   async getComments(cID, commentsArray = []) {



      let comments = await axios.get("/comment/all/" + cID + "?ss", {
         headers: {
            auth: localStorage.getItem("token")
         }
      });
      comments = comments.data.comments;
      commentsArray.push(comments);
      for (const comment of comments) {
         commentsArray = await this.getComments(comment._id + "?comment=true", commentsArray);
      }
      return commentsArray;
      // if(comments.length){
      //    //Save Comments:
      //    if(!this.state.tCOmments){
      //       this.setState({
      //          tCOmments: comments
      //       });
      //    }else{
      //       let lvComments = this.state.tCOmments;
      //       let i = 0;
      //       // while(1){
      //       //    if(i === 0 &amp;&amp; (i >= lvComments.length || typeof lvComments[i] === "number")){
      //       //       console.log("something went horrible");
      //       //       break;
      //       //    }
      //       //    if(i >= lvComments.length || typeof lvComments[i] === "number") {
      //       //       const startingIndex = lvComments.findIndex((el) => typeof el === "number");

      //       //       lvComments = lvComments.map((comment, x) => [...(comment.children || []), ...(startingIndex > 0 ? lvComments.split(startingIndex-1).concat([x]) : [x])]);
      //       //       i = 0;
      //       //       continue;
      //       //    }
      //       //    if(lvComments[i]._id === comments[0].parent_id){
      //       //       lvComments[i].children = comments;
      //       //       const OriginalComments = this.state.tCOmments;
      //       //       const startingIndex = lvComments.findIndex((el) => typeof el === "number");
      //       //       let path = lvComments.split(startingIndex-1);
      //       //       // for(const index in OriginalComments){
      //       //       //     if(index === path[0]){
      //       //       //        OriginalComments.children ? OriginalComments
      //       //       //     }
      //       //       // }  
      //       //       // if(path.length === 1){
      //       //       //    OriginalComments[path[0]].children = comments;
      //       //       // }else{
      //       //          //[0]["children"][1]["children"][2]["children"]
      //       //          let str;
      //       //          for(const pos of path){
      //       //             str.push(`[${pos}]["children"]`);
      //       //          }
      //       //          str = str.join("");
      //       //          const evaluator = Function(`
      //       //             "use strict";
      //       //             return ${OriginalComments}${str};
      //       //          `);
      //       //          console.log("evaluator", evaluator);
      //       //          // evaluator() = comments;
      //       //       // }
      //       //          for(const comment of comments){
      //       //             await this.getComments(comment._id);
      //       //          }
      //       //       break;
      //       //    }
      //       //    i++;
      //       // }
      //    }


      // }
   }

   render() {
      return (

         &lt;div className="page">
            &lt;div class="threadPageContainer">
               &lt;div className="PageThread">
                  &lt;Thread
                     id={this.state.id}
                     username={this.state.creator}
                     subreddit={this.state.subredditName}
                     title={this.state.threadTitle}
                     content={this.state.threadBody}
                     upvotes={this.state.votes}
                     date={this.state.postdate}
                     image={this.state.image}
                     isSpoiler={this.state.isSpoiler}
                  />
               &lt;/div>
               &lt;div class="addCommentSection">
                  &lt;AddComment addComment={this.addComment} />
                  &lt;label for="checkLocked" className="lockComment">Lock&lt;/label>
                  &lt;input type="checkbox" name="checkLocked" id="checkLocked" />
                  &lt;label for="checkSpoiler" className="spoilerComment" >Mark as spoiler&lt;/label>
                  &lt;input type="checkbox" name="checkSpoiler" id="checkSpoiler" />
               &lt;/div>
               &lt;ul class="commentList">
                  {this.getCommentsJSX(this.state.allComments)}
                  {/* {
                     this.state.comments.map(comment => {
                        const isCreator = localStorage.getItem("Username") === comment.username;
                        return (
                           &lt;div>
                              &lt;li className="threadComment" id="commentContainer"  >
                                 &lt;div className="commentUser">u/{comment.username} &lt;/div>
                                 &lt;div className={`comment ${comment.spoiler ? "spoiler" : ""}`}>{comment.content}&lt;/div>
                                 {localStorage.getItem("Username") === comment.username ?
                                    &lt;span>
                                       &lt;button className="editComment" data-id={comment._id} onClick={this.editComment.bind(this)}>Edit&lt;/button>
                                       &lt;button className="deleteComment" data-id={comment._id} onClick={this.deleteComment.bind(this)}>Delete&lt;/button>
                                    &lt;/span>
                                    : null}
                                 {!comment.locked ?
                                    &lt;button className="replyComment" comment-id={comment._id} onClick={this.handleReply} >&lt;i class="fas fa-reply">&lt;/i>&lt;/button>
                                    : null
                                 }
                              &lt;/li>
                              {comment.children ? comment.children.map(child => {
                                 return (
                                    &lt;li className="threadComment reply" id="commentContainer"  >
                                       &lt;div className="commentUser">u/{child.username} &lt;/div>
                                       &lt;div className={`comment ${child.spoiler ? "spoiler" : ""}`}>{child.content}&lt;/div>
                                       {isCreator ?
                                          &lt;span>
                                             &lt;button className="editComment" data-id={child._id} onClick={this.editComment.bind(this)}>Edit&lt;/button>
                                             &lt;button className="deleteComment" data-id={child._id} onClick={this.deleteComment.bind(this)}>Delete&lt;/button>
                                          &lt;/span>
                                          : null}

                                       {!child.locked ?
                                          &lt;button className="replyComment" comment-id={child._id} onClick={this.handleReply} >&lt;i class="fas fa-reply">&lt;/i>&lt;/button>
                                          : null
                                       }
                                    &lt;/li>
                                 )
                              }) : null}
                           &lt;/div>
                        );

                     })

                  } */}

               &lt;/ul>
               {
                  this.state.editComment ?
                     &lt;div className="threadComment2">

                        &lt;form className="editForm" onSubmit={this.onSave}>
                           &lt;input className="textComment" id="textComment" type="text"
                              name="comment" placeholder="Edit your comment here..."
                              value={this.state.comment} onChange={this.onChange}
                           />
                           &lt;br />
                           &lt;label className="lockComment">
                              &lt;input type="checkbox" id="checkLocked2" />
                              Lock
                        &lt;/label>
                           &lt;label className="spoilerComment">
                              &lt;input type="checkbox" id="checkSpoiler2" />
                              Mark as spoiler
                        &lt;/label>
                           &lt;br />
                           &lt;input type="submit" value="Edit" className="goEdit" onClick={this.goEdit.bind(this)} />
                           &lt;input type="submit" value="Cancel" className="goCancel" onClick={this.cancelEditComment} />
                           &lt;br />
                        &lt;/form>
                     &lt;/div> : &lt;div>&lt;/div>
               }
               {
                  this.state.replyComment ?
                     &lt;div className="threadComment2">

                        &lt;form className="editForm" onSubmit={this.onSave}>
                           &lt;input className="textReply textComment" id="textReply" type="text"
                              name="comment" placeholder="Reply here..."
                              value={this.state.comment} onChange={this.onChange}
                           />
                           &lt;br />

                           &lt;label className="lockComment">
                              &lt;input type="checkbox" id="checkLocked3" />
                              Lock
                           &lt;/label>
                           &lt;label className="spoilerComment">
                              &lt;input type="checkbox" id="checkSpoiler3" />
                              Mark as spoiler
                        &lt;/label>
                           &lt;br />
                           &lt;input type="submit" value="Reply" className="goReply" onClick={this.replyComment.bind(this)} />
                           &lt;input type="submit" value="Cancel" className="goCancel" onClick={this.cancelReplyComment} />

                        &lt;/form>
                     &lt;/div> : &lt;div>&lt;/div>
               }
            &lt;/div>








            &lt;div className="threadPageSidebarContainer">

               {
                  (this.state.creator == localStorage.getItem("Username")) ?
                     &lt;div className="threadPageSidebarComponent1">
                        &lt;button className="threadPageSidebarEditButton1" onClick={this.editPost}>EDIT POST&lt;/button>
                        &lt;button className="threadPageSidebarDeleteButton" onClick={this.delPost}>DELETE POST&lt;/button>
                     &lt;/div>
                     : &lt;div>&lt;/div>

               }

               {
                  this.state.editThread ?
                     &lt;div className="threadPageSidebarComponent3">
                        &lt;h5>EDIT POST&lt;/h5>
                        &lt;hr>&lt;/hr>
                        &lt;form onSubmit={this.handleEdit}>
                           &lt;div className="formGroupthreadComponent1">
                              &lt;label for="newThreadTitle">Enter new Title&lt;/label>
                              &lt;textarea type="textarea" name="text" id="newThreadTitleField" placeholder="Enter Title Here" />
                           &lt;/div>
                           {
                              this.state.errornumber == 1 ?
                                 &lt;div className="errorMessageEditPost">
                                    *Please provide a  new title for the post
                              &lt;/div> : &lt;div>&lt;/div>
                           }
                           &lt;div className="formGroupSrComponent2">
                              &lt;label for="newThreadBody">Enter new Thread Body&lt;/label>
                              &lt;textarea type="textarea" name="text" id="newThreadBodyField" placeholder="Enter Body Here" />
                           &lt;/div>
                           {
                              this.state.errornumber == 2 ?
                                 &lt;div className="errorMessageEditPost">
                                    *Please provide a new body for the post
                              &lt;/div> : &lt;div>&lt;/div>
                           }
                           &lt;button className="threadPageSidebarEditButton2" >EDIT POST&lt;/button>
                           &lt;button className="threadPageSidebarCancelEditButton" onClick={this.cancelEdit}>CANCEL&lt;/button>
                        &lt;/form>
                     &lt;/div> : &lt;div>&lt;/div>
               }

            &lt;/div>
         &lt;/div>






      );

   }


}

export default ThreadPage;</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Global</h3><ul><li><a href="global.html#_handleInputChange">_handleInputChange</a></li><li><a href="global.html#_handleOnSubmit">_handleOnSubmit</a></li><li><a href="global.html#BanUser">BanUser</a></li><li><a href="global.html#blockList">blockList</a></li><li><a href="global.html#BlockUser">BlockUser</a></li><li><a href="global.html#CancelCreation">CancelCreation</a></li><li><a href="global.html#cancelEdit">cancelEdit</a></li><li><a href="global.html#cancelSubreddit">cancelSubreddit</a></li><li><a href="global.html#cardViewHandler">cardViewHandler</a></li><li><a href="global.html#checkforpostorcomment">checkforpostorcomment</a></li><li><a href="global.html#checkValidity">checkValidity</a></li><li><a href="global.html#classicViewHandler">classicViewHandler</a></li><li><a href="global.html#closeBlockList">closeBlockList</a></li><li><a href="global.html#closeLogin">closeLogin</a></li><li><a href="global.html#closeRegistration">closeRegistration</a></li><li><a href="global.html#CreateFlair">CreateFlair</a></li><li><a href="global.html#createThread">createThread</a></li><li><a href="global.html#createThreads">createThreads</a></li><li><a href="global.html#createThreadSidebar">createThreadSidebar</a></li><li><a href="global.html#DeleteReport">DeleteReport</a></li><li><a href="global.html#DeleteReportedComment">DeleteReportedComment</a></li><li><a href="global.html#DeleteReportedPost">DeleteReportedPost</a></li><li><a href="global.html#delPost">delPost</a></li><li><a href="global.html#editPost">editPost</a></li><li><a href="global.html#editSubreddit">editSubreddit</a></li><li><a href="global.html#filterList">filterList</a></li><li><a href="global.html#getBlockList">getBlockList</a></li><li><a href="global.html#getCurrentUser">getCurrentUser</a></li><li><a href="global.html#getFlairs">getFlairs</a></li><li><a href="global.html#getListing">getListing</a></li><li><a href="global.html#getMsgs">getMsgs</a></li><li><a href="global.html#getNotif">getNotif</a></li><li><a href="global.html#getReports">getReports</a></li><li><a href="global.html#getThreads">getThreads</a></li><li><a href="global.html#goTo">goTo</a></li><li><a href="global.html#goToCreatePost">goToCreatePost</a></li><li><a href="global.html#goToCreateSr">goToCreateSr</a></li><li><a href="global.html#gotoMod">gotoMod</a></li><li><a href="global.html#handleAboutChange">handleAboutChange</a></li><li><a href="global.html#handleBlock">handleBlock</a></li><li><a href="global.html#handleChange">handleChange</a></li><li><a href="global.html#handleClick">handleClick</a></li><li><a href="global.html#handledecrement">handledecrement</a></li><li><a href="global.html#handleEdit">handleEdit</a></li><li><a href="global.html#handleFileChange">handleFileChange</a></li><li><a href="global.html#handleFriend">handleFriend</a></li><li><a href="global.html#handleIncrement">handleIncrement</a></li><li><a href="global.html#handleLoginContainerClick">handleLoginContainerClick</a></li><li><a href="global.html#handleNewImage">handleNewImage</a></li><li><a href="global.html#handleNewPasswordChange">handleNewPasswordChange</a></li><li><a href="global.html#handleRegContainerClick">handleRegContainerClick</a></li><li><a href="global.html#handleSubmit">handleSubmit</a></li><li><a href="global.html#handleUnblock">handleUnblock</a></li><li><a href="global.html#leavemoderation">leavemoderation</a></li><li><a href="global.html#logout">logout</a></li><li><a href="global.html#MarkRead">MarkRead</a></li><li><a href="global.html#MarkReadAll">MarkReadAll</a></li><li><a href="global.html#MarkUnRead">MarkUnRead</a></li><li><a href="global.html#MarkUnReadAll">MarkUnReadAll</a></li><li><a href="global.html#onChange">onChange</a></li><li><a href="global.html#onChangeSr">onChangeSr</a></li><li><a href="global.html#onChangeUser">onChangeUser</a></li><li><a href="global.html#onSave">onSave</a></li><li><a href="global.html#openLogInDialogue">openLogInDialogue</a></li><li><a href="global.html#openRegDialogue">openRegDialogue</a></li><li><a href="global.html#removeReq">removeReq</a></li><li><a href="global.html#reply">reply</a></li><li><a href="global.html#setSR">setSR</a></li><li><a href="global.html#sortHandHot">sortHandHot</a></li><li><a href="global.html#sortHandNew">sortHandNew</a></li><li><a href="global.html#sortHandTop">sortHandTop</a></li><li><a href="global.html#srSubscribe">srSubscribe</a></li><li><a href="global.html#srUnSubscribe">srUnSubscribe</a></li><li><a href="global.html#unBlockUser">unBlockUser</a></li><li><a href="global.html#Unfriend">Unfriend</a></li><li><a href="global.html#userHasLoggedIn">userHasLoggedIn</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.5.5</a> on Tue May 07 2019 22:19:47 GMT+0200 (Eastern European Standard Time)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
